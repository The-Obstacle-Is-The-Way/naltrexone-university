# SPEC-006: Drizzle Schema

**Status:** Ready
**Layer:** Infrastructure (Outermost)
**Dependencies:** SPEC-001 (Entities), SPEC-002 (Value Objects)
**Implements:** ADR-001, ADR-002

---

## Objective

Define the Drizzle ORM schema that maps domain entities to PostgreSQL tables. This is infrastructure code that has **no business logic** - it only defines table structures, indexes, and relations.

---

## Files to Create

```
db/
├── schema.ts
├── index.ts
└── migrations/
    └── (generated by drizzle-kit)
```

---

## Design Pattern: Data Mapper

```
┌─────────────────────────────────────────────────┐
│           DOMAIN LAYER (pure types)             │
│                                                 │
│   User, Question, Choice, Attempt, etc.         │
│   (readonly, no DB knowledge)                   │
└─────────────────────────────────────────────────┘
                    ▲
                    │ maps to/from
                    │
┌─────────────────────────────────────────────────┐
│         INFRASTRUCTURE (Drizzle schema)         │
│                                                 │
│   users, questions, choices, attempts tables    │
│   (DB-specific: UUIDs, indexes, relations)      │
└─────────────────────────────────────────────────┘
```

---

## Test First

### File: `db/schema.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import {
  users,
  questions,
  choices,
  tags,
  questionTags,
  attempts,
  practiceSessions,
  bookmarks,
  stripeCustomers,
  stripeSubscriptions,
  stripeEvents,
} from './schema';

describe('Drizzle Schema', () => {
  describe('users table', () => {
    it('has required columns', () => {
      expect(users.id).toBeDefined();
      expect(users.clerkUserId).toBeDefined();
      expect(users.email).toBeDefined();
      expect(users.createdAt).toBeDefined();
      expect(users.updatedAt).toBeDefined();
    });
  });

  describe('questions table', () => {
    it('has required columns', () => {
      expect(questions.id).toBeDefined();
      expect(questions.slug).toBeDefined();
      expect(questions.stemMd).toBeDefined();
      expect(questions.explanationMd).toBeDefined();
      expect(questions.difficulty).toBeDefined();
      expect(questions.status).toBeDefined();
    });
  });

  describe('choices table', () => {
    it('has required columns', () => {
      expect(choices.id).toBeDefined();
      expect(choices.questionId).toBeDefined();
      expect(choices.label).toBeDefined();
      expect(choices.textMd).toBeDefined();
      expect(choices.isCorrect).toBeDefined();
      expect(choices.sortOrder).toBeDefined();
    });
  });

  describe('attempts table', () => {
    it('has required columns', () => {
      expect(attempts.id).toBeDefined();
      expect(attempts.userId).toBeDefined();
      expect(attempts.questionId).toBeDefined();
      expect(attempts.practiceSessionId).toBeDefined();
      expect(attempts.selectedChoiceId).toBeDefined();
      expect(attempts.isCorrect).toBeDefined();
      expect(attempts.timeSpentSeconds).toBeDefined();
      expect(attempts.answeredAt).toBeDefined();
    });
  });

  describe('stripe tables', () => {
    it('stripeCustomers has required columns', () => {
      expect(stripeCustomers.id).toBeDefined();
      expect(stripeCustomers.userId).toBeDefined();
      expect(stripeCustomers.stripeCustomerId).toBeDefined();
    });

    it('stripeSubscriptions has required columns', () => {
      expect(stripeSubscriptions.id).toBeDefined();
      expect(stripeSubscriptions.userId).toBeDefined();
      expect(stripeSubscriptions.stripeSubscriptionId).toBeDefined();
      expect(stripeSubscriptions.status).toBeDefined();
      expect(stripeSubscriptions.currentPeriodEnd).toBeDefined();
    });

    it('stripeEvents has required columns', () => {
      expect(stripeEvents.id).toBeDefined();
      expect(stripeEvents.type).toBeDefined();
      expect(stripeEvents.processedAt).toBeDefined();
    });
  });
});
```

---

## Implementation

### File: `db/schema.ts`

```typescript
import {
  boolean,
  index,
  integer,
  jsonb,
  pgEnum,
  pgTable,
  primaryKey,
  text,
  timestamp,
  uniqueIndex,
  uuid,
  varchar,
} from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
import { desc } from 'drizzle-orm';

/**
 * ENUMS
 */
export const questionDifficultyEnum = pgEnum('question_difficulty', [
  'easy',
  'medium',
  'hard',
]);

export const questionStatusEnum = pgEnum('question_status', [
  'draft',
  'published',
  'archived',
]);

export const tagKindEnum = pgEnum('tag_kind', [
  'domain',
  'topic',
  'substance',
  'treatment',
  'diagnosis',
]);

export const practiceModeEnum = pgEnum('practice_mode', [
  'tutor',
  'exam',
]);

export const stripeSubscriptionStatusEnum = pgEnum('stripe_subscription_status', [
  'incomplete',
  'incomplete_expired',
  'trialing',
  'active',
  'past_due',
  'canceled',
  'unpaid',
  'paused',
]);

/**
 * Session params stored as JSONB
 */
export type PracticeSessionParams = {
  count: number;
  tagSlugs: string[];
  difficulties: string[];
  questionIds: string[];
};

/**
 * TABLES
 */

// users
export const users = pgTable(
  'users',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    clerkUserId: varchar('clerk_user_id', { length: 64 }).notNull(),
    email: varchar('email', { length: 320 }).notNull(),
    createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow(),
  },
  (t) => ({
    clerkUserIdUq: uniqueIndex('users_clerk_user_id_uq').on(t.clerkUserId),
    emailUq: uniqueIndex('users_email_uq').on(t.email),
  }),
);

// stripe_customers
export const stripeCustomers = pgTable(
  'stripe_customers',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    userId: uuid('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),
    stripeCustomerId: varchar('stripe_customer_id', { length: 255 }).notNull(),
    createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
  },
  (t) => ({
    userIdUq: uniqueIndex('stripe_customers_user_id_uq').on(t.userId),
    stripeCustomerIdUq: uniqueIndex('stripe_customers_stripe_customer_id_uq').on(
      t.stripeCustomerId,
    ),
  }),
);

// stripe_subscriptions
export const stripeSubscriptions = pgTable(
  'stripe_subscriptions',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    userId: uuid('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),
    stripeSubscriptionId: varchar('stripe_subscription_id', { length: 255 }).notNull(),
    status: stripeSubscriptionStatusEnum('status').notNull(),
    priceId: varchar('price_id', { length: 255 }).notNull(),
    currentPeriodEnd: timestamp('current_period_end', { withTimezone: true }).notNull(),
    cancelAtPeriodEnd: boolean('cancel_at_period_end').notNull().default(false),
    createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow(),
  },
  (t) => ({
    userIdUq: uniqueIndex('stripe_subscriptions_user_id_uq').on(t.userId),
    stripeSubscriptionIdUq: uniqueIndex(
      'stripe_subscriptions_stripe_subscription_id_uq',
    ).on(t.stripeSubscriptionId),
    userStatusIdx: index('stripe_subscriptions_user_status_idx').on(
      t.userId,
      t.status,
    ),
  }),
);

// stripe_events (idempotency tracking)
export const stripeEvents = pgTable(
  'stripe_events',
  {
    id: varchar('id', { length: 255 }).primaryKey(),
    type: varchar('type', { length: 255 }).notNull(),
    processedAt: timestamp('processed_at', { withTimezone: true }),
    error: text('error'),
  },
  (t) => ({
    typeIdx: index('stripe_events_type_idx').on(t.type),
    processedAtIdx: index('stripe_events_processed_at_idx').on(t.processedAt),
  }),
);

// questions
export const questions = pgTable(
  'questions',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    slug: varchar('slug', { length: 255 }).notNull(),
    stemMd: text('stem_md').notNull(),
    explanationMd: text('explanation_md').notNull(),
    difficulty: questionDifficultyEnum('difficulty').notNull(),
    status: questionStatusEnum('status').notNull(),
    createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow(),
  },
  (t) => ({
    slugUq: uniqueIndex('questions_slug_uq').on(t.slug),
    statusDifficultyIdx: index('questions_status_difficulty_idx').on(
      t.status,
      t.difficulty,
    ),
    statusCreatedAtIdx: index('questions_status_created_at_idx').on(
      t.status,
      desc(t.createdAt),
    ),
  }),
);

// choices
export const choices = pgTable(
  'choices',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    questionId: uuid('question_id')
      .notNull()
      .references(() => questions.id, { onDelete: 'cascade' }),
    label: varchar('label', { length: 4 }).notNull(),
    textMd: text('text_md').notNull(),
    isCorrect: boolean('is_correct').notNull(),
    sortOrder: integer('sort_order').notNull(),
  },
  (t) => ({
    questionIdIdx: index('choices_question_id_idx').on(t.questionId),
    questionLabelUq: uniqueIndex('choices_question_id_label_uq').on(
      t.questionId,
      t.label,
    ),
    questionSortOrderUq: uniqueIndex('choices_question_id_sort_order_uq').on(
      t.questionId,
      t.sortOrder,
    ),
  }),
);

// tags
export const tags = pgTable(
  'tags',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    slug: varchar('slug', { length: 255 }).notNull(),
    name: varchar('name', { length: 255 }).notNull(),
    kind: tagKindEnum('kind').notNull(),
  },
  (t) => ({
    slugUq: uniqueIndex('tags_slug_uq').on(t.slug),
    kindSlugIdx: index('tags_kind_slug_idx').on(t.kind, t.slug),
  }),
);

// question_tags (junction table)
export const questionTags = pgTable(
  'question_tags',
  {
    questionId: uuid('question_id')
      .notNull()
      .references(() => questions.id, { onDelete: 'cascade' }),
    tagId: uuid('tag_id')
      .notNull()
      .references(() => tags.id, { onDelete: 'cascade' }),
  },
  (t) => ({
    pk: primaryKey({ columns: [t.questionId, t.tagId] }),
    tagIdIdx: index('question_tags_tag_id_idx').on(t.tagId),
    questionIdIdx: index('question_tags_question_id_idx').on(t.questionId),
  }),
);

// practice_sessions
export const practiceSessions = pgTable(
  'practice_sessions',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    userId: uuid('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),
    mode: practiceModeEnum('mode').notNull(),
    paramsJson: jsonb('params_json').$type<PracticeSessionParams>().notNull(),
    startedAt: timestamp('started_at', { withTimezone: true }).notNull().defaultNow(),
    endedAt: timestamp('ended_at', { withTimezone: true }),
  },
  (t) => ({
    userStartedAtIdx: index('practice_sessions_user_started_at_idx').on(
      t.userId,
      desc(t.startedAt),
    ),
  }),
);

// attempts
export const attempts = pgTable(
  'attempts',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    userId: uuid('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),
    questionId: uuid('question_id')
      .notNull()
      .references(() => questions.id, { onDelete: 'cascade' }),
    practiceSessionId: uuid('practice_session_id').references(() => practiceSessions.id, {
      onDelete: 'set null',
    }),
    selectedChoiceId: uuid('selected_choice_id').references(() => choices.id, {
      onDelete: 'set null',
    }),
    isCorrect: boolean('is_correct').notNull(),
    timeSpentSeconds: integer('time_spent_seconds').notNull().default(0),
    answeredAt: timestamp('answered_at', { withTimezone: true }).notNull().defaultNow(),
  },
  (t) => ({
    userAnsweredAtIdx: index('attempts_user_answered_at_idx').on(
      t.userId,
      desc(t.answeredAt),
    ),
    userQuestionIdx: index('attempts_user_question_idx').on(
      t.userId,
      t.questionId,
    ),
    sessionIdx: index('attempts_session_idx').on(t.practiceSessionId),
  }),
);

// bookmarks (composite PK)
export const bookmarks = pgTable(
  'bookmarks',
  {
    userId: uuid('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),
    questionId: uuid('question_id')
      .notNull()
      .references(() => questions.id, { onDelete: 'cascade' }),
    createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
  },
  (t) => ({
    pk: primaryKey({ columns: [t.userId, t.questionId] }),
    userCreatedAtIdx: index('bookmarks_user_created_at_idx').on(
      t.userId,
      desc(t.createdAt),
    ),
  }),
);

/**
 * RELATIONS
 */
export const usersRelations = relations(users, ({ one, many }) => ({
  stripeCustomer: one(stripeCustomers, {
    fields: [users.id],
    references: [stripeCustomers.userId],
  }),
  stripeSubscription: one(stripeSubscriptions, {
    fields: [users.id],
    references: [stripeSubscriptions.userId],
  }),
  sessions: many(practiceSessions),
  attempts: many(attempts),
  bookmarks: many(bookmarks),
}));

export const questionsRelations = relations(questions, ({ many }) => ({
  choices: many(choices),
  questionTags: many(questionTags),
  attempts: many(attempts),
  bookmarks: many(bookmarks),
}));

export const choicesRelations = relations(choices, ({ one }) => ({
  question: one(questions, {
    fields: [choices.questionId],
    references: [questions.id],
  }),
}));

export const tagsRelations = relations(tags, ({ many }) => ({
  questionTags: many(questionTags),
}));

export const questionTagsRelations = relations(questionTags, ({ one }) => ({
  question: one(questions, {
    fields: [questionTags.questionId],
    references: [questions.id],
  }),
  tag: one(tags, {
    fields: [questionTags.tagId],
    references: [tags.id],
  }),
}));

export const practiceSessionsRelations = relations(practiceSessions, ({ one, many }) => ({
  user: one(users, {
    fields: [practiceSessions.userId],
    references: [users.id],
  }),
  attempts: many(attempts),
}));

export const attemptsRelations = relations(attempts, ({ one }) => ({
  user: one(users, {
    fields: [attempts.userId],
    references: [users.id],
  }),
  question: one(questions, {
    fields: [attempts.questionId],
    references: [questions.id],
  }),
  session: one(practiceSessions, {
    fields: [attempts.practiceSessionId],
    references: [practiceSessions.id],
  }),
  selectedChoice: one(choices, {
    fields: [attempts.selectedChoiceId],
    references: [choices.id],
  }),
}));

export const bookmarksRelations = relations(bookmarks, ({ one }) => ({
  user: one(users, {
    fields: [bookmarks.userId],
    references: [users.id],
  }),
  question: one(questions, {
    fields: [bookmarks.questionId],
    references: [questions.id],
  }),
}));
```

### File: `db/index.ts`

```typescript
export * from './schema';
```

---

## Quality Gate

```bash
pnpm test db/
pnpm db:generate  # Generate migration
```

---

## Definition of Done

- [ ] All tables defined with proper types
- [ ] UUID primary keys with defaultRandom()
- [ ] Timestamptz for all date columns
- [ ] Proper indexes for query patterns
- [ ] Relations defined for Drizzle query API
- [ ] Tests verify column existence
- [ ] Migration generates successfully
